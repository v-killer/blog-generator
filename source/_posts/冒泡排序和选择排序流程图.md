---
title: 冒泡排序和选择排序流程图
date: 2018-08-29 14:54:15
tags:
---
### 冒泡排序
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

#### 冒泡排序流程图

![](https://user-gold-cdn.xitu.io/2018/6/25/16436af307e81502?w=498&h=1020&f=png&s=40181)

#### 伪代码
    
    a <- {
    '0':4,
    '1':6,
    '2':3,
    '3':2,
    '4':1,
    'length': 5
    }
    轮数 = 1
    左手指向的下标 

    while(轮数 < a['length'])
        左标 = 0
        while(左标 <= a['length'] - 1 - 轮数)
            if a[左下标] < a[左下标+1]
            else
                t <- a[左标]
                a[左标] <- a[左标+1]
                a[左标+1] <- t
            end
            左标 <- 左标+1
        end
        轮数 <- 轮数 + 1
    end
    print a
    
### 选择排序
**工作原理**: 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

#### 选择排序流程图
![](https://user-gold-cdn.xitu.io/2018/6/11/163ee33b498539b7?w=454&h=1022&f=png&s=43998)

#### 伪代码
    
        a<-{
        '0'=4,
        '1'=6,
        '2'=3,
        '3'=2,
        '4'=1,
        'length'=5
    }
    轮数=1
        while(轮数<a['length'])
            min左标<-轮数-1;左标<-min左标+1
            while(左标<a['length'])
                if  a[左标]<a[min左标]
                    a[min左标]<-a[左标]
                else
                    什么也不做
                end
                左标<-左标+1
            end
            t<-a[轮数-1]
            a[轮数-1]<-a[min左标]
            a[min左标]<-t
            
            轮数<-轮数+1
        end
        print a